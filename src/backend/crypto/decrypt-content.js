// Decrypt Content Utility
// Symmetric counterpart to `encrypt-content.js`; converts cipher text generated by that utility
// back to its original form while preserving the data type (Buffer vs. string) and character
// encoding metadata.

// Purpose:
// - Provide a single entry-point for decrypting both text (base-64 string) and binary (Buffer) inputs
// - Automatically detect Buffer (binary) versus string (text) cipher representations
// - Detect resulting text encoding via `chardet` for downstream use
// - Centralise `node:crypto` AES-256-CBC usage (salt + IV prepended cipher design)
// - Surface simple, hard-coded error messages; no external constants required

// Dependencies:
// - node:crypto – Symmetric decryption (AES-256-CBC)
// - chardet – Best-effort character-set detection post-decryption

// Usage Examples:
// ```javascript
// const { decryptContent } = require('@backend/crypto/decrypt-content');
//
// // Text (base-64) ➜ UTF-8 string
// const txtCipher = fs.readFileSync('note.enc', 'utf-8');
// const txtRes = await decryptContent(txtCipher, 'myp4ss');
// if (txtRes.success) console.log(txtRes.content); // original note text
//
// // Binary (Buffer) ➜ Buffer
// const imgCipher = await fs.readFile('photo.enc');
// const imgRes = await decryptContent(imgCipher, 'myp4ss');
// if (imgRes.success && Buffer.isBuffer(imgRes.content)) {
//   fs.writeFileSync('photo.jpg', imgRes.content);
// }
// ```

// Integration Points:
// - File decryption workflow (`decrypt-file.js`)
// - IPC handlers that expose decryption to the renderer
// - CLI or background jobs needing bulk decryption

// Process/Operation Flow:
// 1. Validate `content` & `password`
// 2. Identify if `content` is Buffer or base-64 string and ensure Buffer form
// 3. Extract Salt (first 16 bytes) and IV (next 16 bytes)
// 4. Derive 32-byte key via `crypto.scryptSync(password, salt, 32)`
// 5. Decrypt data using AES-256-CBC
// 6. Detect encoding (text inputs) with `chardet`
// 7. Return decrypted data (Buffer or UTF-8 string), plus metadata (`encoding`, `isBuffer`)

const crypto = require("crypto");
const { detectEncoding } = require("@backend/file-manager/detect-encoding");

/**
 * Decrypt arbitrary content previously encrypted with AES.
 * Detects Buffer vs string and returns corresponding decrypted format.
 *
 * @param {string|Buffer} content – Cipher text produced by `encrypt-content.js`.
 *   • Text inputs must be base-64 strings.
 *   • Binary inputs must be Buffers.
 * @param {string} password – Password used during encryption; required for key derivation.
 * @returns {Promise<Object>} Result object
 * @property {boolean} success – `true` when decryption succeeds.
 * @property {string|Buffer} [content] – Original data. Buffer for binary inputs, string for text inputs.
 * @property {string} [encoding] – Detected character encoding for text outputs. Defaults to "binary" if not detected.
 * @property {boolean} [isBuffer] – `true` if the decrypted result is a Buffer (i.e., original input was also a Buffer).
 * @property {string} [error] – Present when `success === false`, contains user-friendly error description.
 *
 * @throws {Error} "Invalid content provided" – When `content` is missing/invalid or cipher header is malformed.
 * @throws {Error} "Invalid password provided" – When `password` is falsy.
 * @throws {Error} "Decryption failed" – When decryption or decoding fails (e.g., wrong password).
 *
 * @example
 * // Text decryption
 * const res = await decryptContent(cipherBase64, 'secret');
 * if (res.success) console.log(res.content);
 *
 * @example
 * // Binary decryption
 * const resBin = await decryptContent(cipherBuffer, 'secret');
 * if (resBin.success && Buffer.isBuffer(resBin.content)) {
 *   // resBin.content is the original Buffer
 * }
 */
async function decryptContent(content, password) {
  try {
    if (content === undefined || content === null) {
      throw new Error("Invalid content provided");
    }
    if (!password) {
      throw new Error("Invalid password provided");
    }

    const isBuffer = Buffer.isBuffer(content);

    // Obtain encrypted bytes from input
    const encryptedBuffer = isBuffer ? content : Buffer.from(content, "base64");

    // Minimum length check: salt(16) + iv(16) = 32
    if (encryptedBuffer.length < 32) {
      throw new Error("Invalid content provided");
    }

    const salt = encryptedBuffer.subarray(0, 16);
    const iv = encryptedBuffer.subarray(16, 32);
    const data = encryptedBuffer.subarray(32);

    try {
      const key = crypto.scryptSync(password, salt, 32);
      const decipher = crypto.createDecipheriv("aes-256-cbc", key, iv);

      const decryptedBuffer = Buffer.concat([
        decipher.update(data),
        decipher.final(),
      ]);

      let encoding = detectEncoding(decryptedBuffer);

      const decryptedOutput = isBuffer
        ? decryptedBuffer
        : decryptedBuffer.toString(encoding);

      if (!encoding) {
        encoding = "binary";
      }

      return {
        success: true,
        content: decryptedOutput,
        isBuffer,
        encoding,
      };
    } catch (_err) {
      throw new Error("Decryption failed");
    }
  } catch (error) {
    return {
      success: false,
      error: error.message,
    };
  }
}

module.exports = { decryptContent };
